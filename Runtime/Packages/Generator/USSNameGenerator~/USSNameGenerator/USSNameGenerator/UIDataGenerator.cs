#nullable enable
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TCS.Generators;

[Generator] public sealed class UiDataGenerator : ISourceGenerator {
    const string ATTRIBUTE_NAME = "AutoBindAttribute";

    public void Initialize(GeneratorInitializationContext context) {
        context.RegisterForSyntaxNotifications( static () => new FieldReceiver() );
    }

    public void Execute(GeneratorExecutionContext context) {
        if ( context.SyntaxReceiver is not FieldReceiver receiver ) return;

        var compilation = context.Compilation;
        var uiDataA = compilation.GetTypeByMetadataName( ATTRIBUTE_NAME );
        if ( uiDataA is null ) return;

        Dictionary<INamedTypeSymbol, List<IFieldSymbol>> byClass = new(SymbolEqualityComparer.Default);

        foreach (var fieldDecl in receiver.CandidateFields) {
            var model = compilation.GetSemanticModel( fieldDecl.SyntaxTree );
            foreach (var variable in fieldDecl.Declaration.Variables) {
                if ( model.GetDeclaredSymbol( variable ) is not IFieldSymbol field ) continue;
                if ( !HasAttribute( field, uiDataA ) ) continue;

                var owner = field.ContainingType;
                if ( !byClass.TryGetValue( owner, out List<IFieldSymbol>? list ) ) {
                    list = [];
                    byClass.Add( owner, list );
                }

                list.Add( field );
            }
        }

        foreach (KeyValuePair<INamedTypeSymbol, List<IFieldSymbol>> kvp in byClass) // <-- standard foreach
        {
            var cls = kvp.Key;
            List<IFieldSymbol> fields = kvp.Value;

            bool isPartial = cls.DeclaringSyntaxReferences
                .Select( r => r.GetSyntax() )
                .OfType<TypeDeclarationSyntax>()
                .Any( t => t.Modifiers.Any( SyntaxKind.PartialKeyword ) );

            if ( !isPartial ) {
                var diag = Diagnostic.Create
                (
                    new DiagnosticDescriptor
                    (
                        "AutoBind001",
                        "[AutoBind] applied to non-partial class",
                        "Class '{0}' must be declared partial when using [AutoBind]",
                        "AutoBindGenerator",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true
                    ),
                    cls.Locations.FirstOrDefault(),
                    cls.Name
                );
                context.ReportDiagnostic( diag );
                continue;
            }

            string source = GenerateSourceForClass( cls, fields );
            context.AddSource( $"{cls.Name}.Notify.g.cs", SourceText.From( source, Encoding.UTF8 ) );
        }
    }

    // ---------- helpers ----------------------------------------------------------

    static bool HasAttribute(ISymbol symbol, INamedTypeSymbol attrSymbol) =>
        symbol.GetAttributes().Any( a => SymbolEqualityComparer.Default.Equals( a.AttributeClass, attrSymbol ) );

    static string GenerateSourceForClass(INamedTypeSymbol cls, IEnumerable<IFieldSymbol> fields) {
        string? ns = cls.ContainingNamespace.IsGlobalNamespace ? null : cls.ContainingNamespace.ToDisplayString();
        var sb = new StringBuilder();
        sb.AppendLine( "// <auto-generated/> This Code was autogenerated by the AutoBindGenerator" );
        sb.AppendLine( "using System;" );
        sb.AppendLine( "using System.Runtime.CompilerServices;" );
        sb.AppendLine( "using Unity.Properties;" );
        sb.AppendLine( "using UnityEngine;" );
        sb.AppendLine( "using UnityEngine.UIElements;" );

        if ( ns != null ) {
            sb.AppendLine( $"namespace {ns}" );
            sb.AppendLine( "{" );
        }

        string indent = ns != null ? "    " : string.Empty;
        sb.AppendLine( $"{indent}partial class {cls.Name} : IDataSourceViewHashProvider, INotifyBindablePropertyChanged" );
        sb.AppendLine( $"{indent}{{" );
        indent += "    ";

        sb.AppendLine( $"{indent}public event EventHandler<BindablePropertyChangedEventArgs> propertyChanged;" );
        sb.AppendLine( $"{indent}long m_viewVersion;" );

        foreach (var f in fields) {
            string fieldName = f.Name;
            string propertyName = ToPascal( fieldName );
            string fieldTypeName = f.Type.ToDisplayString( SymbolDisplayFormat.MinimallyQualifiedFormat );

            sb.AppendLine();
            sb.AppendLine( $"{indent}[CreateProperty]" );
            sb.AppendLine( $"{indent}public {fieldTypeName} {propertyName}" );
            sb.AppendLine( $"{indent}{{" );
            sb.AppendLine( $"{indent}    get => {fieldName};" );
            sb.AppendLine( $"{indent}    set" );
            sb.AppendLine( $"{indent}    {{" );

            string compare =
                f.Type.SpecialType is SpecialType.System_Single or SpecialType.System_Double
                    ? $"Mathf.Approximately({fieldName}, value)"
                    : $"{fieldName}.Equals(value)";

            sb.AppendLine( $"{indent}        if ({compare}) return;" );
            sb.AppendLine( $"{indent}        {fieldName} = value;" );
            sb.AppendLine( $"{indent}        ++m_viewVersion;" );
            sb.AppendLine( $"{indent}        Notify();" );
            sb.AppendLine( $"{indent}    }}" );
            sb.AppendLine( $"{indent}}}" );
        }

        sb.AppendLine();
        sb.AppendLine( $"{indent}void Notify([CallerMemberName] string propName = null)" );
        sb.AppendLine( $"{indent}{{" );
        //sb.AppendLine( $"{indent}    Publish();" );
        sb.AppendLine( $"{indent}    propertyChanged?.Invoke(this, new BindablePropertyChangedEventArgs(propName));" );
        sb.AppendLine( $"{indent}}}" );
        sb.AppendLine();
        sb.AppendLine( $"{indent}public void Publish() => ++m_viewVersion;" );
        sb.AppendLine( $"{indent}public long GetViewHashCode() => m_viewVersion;" );

        indent = indent[..^4];
        sb.AppendLine( $"{indent}}}" );
        if ( ns != null ) sb.AppendLine( "}" );
        return sb.ToString();
    }

    static string ToPascal(string fieldName) {
        string core = fieldName.StartsWith( "m_" ) ? fieldName[2..] :
            fieldName.StartsWith( "_" ) ? fieldName[1..] : fieldName;
        return core.Length switch {
            0 => fieldName,
            1 => char.ToUpperInvariant( core[0] ).ToString(),
            _ => char.ToUpperInvariant( core[0] ) + core[1..]
        };
    }

    // receiver -------------------------------------------------------
    sealed class FieldReceiver : ISyntaxReceiver {
        public List<FieldDeclarationSyntax> CandidateFields { get; } = [];
        public void OnVisitSyntaxNode(SyntaxNode node) {
            if ( node is FieldDeclarationSyntax { AttributeLists.Count: > 0 } f )
                CandidateFields.Add( f );
        }
    }
}